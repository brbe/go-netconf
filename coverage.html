
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>netconf: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nemith/netconf/capability.go (83.3%)</option>
				
				<option value="file1">github.com/nemith/netconf/msg.go (0.0%)</option>
				
				<option value="file2">github.com/nemith/netconf/session.go (17.4%)</option>
				
				<option value="file3">github.com/nemith/netconf/xml.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package netconf

const (
        baseCap      = "urn:ietf:params:netconf:base"
        stdCapPrefix = "urn:ietf:params:netconf:capability"
)

// DefaultCapabilties are the capabilties sent by the client during the hello
// exchange by the server.
var DefaultCapabilities = []string{
        "urn:ietf:params:netconf:base:1.0",
        "urn:ietf:params:netconf:base:1.1",

        // XXX: these seems like server capabilities and i don't see why
        // a client would need to send them

        // "urn:ietf:params:netconf:capability:writable-running:1.0",
        // "urn:ietf:params:netconf:capability:candidate:1.0",
        // "urn:ietf:params:netconf:capability:confirmed-commit:1.0",
        // "urn:ietf:params:netconf:capability:rollback-on-error:1.0",
        // "urn:ietf:params:netconf:capability:startup:1.0",
        // "urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp",
        // "urn:ietf:params:netconf:capability:validate:1.0",
        // "urn:ietf:params:netconf:capability:xpath:1.0",
        // "urn:ietf:params:netconf:capability:notification:1.0",
        // "urn:ietf:params:netconf:capability:interleave:1.0",
        // "urn:ietf:params:netconf:capability:with-defaults:1.0",
}

// ExpandCapability will automatically add the standard capability prefix of
// `urn:ietf:params:netconf:capability` if not already present.
func ExpandCapability(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">if s[0] != ':' </span><span class="cov8" title="1">{
                return s
        }</span>

        <span class="cov0" title="0">return stdCapPrefix + s</span>
}

// XXX: may want to expose this type publically in the future when the api has
// stabilized?
type capabilitySet struct {
        caps map[string]struct{}
}

func newCapabilitySet(capabilities ...string) capabilitySet <span class="cov8" title="1">{
        cs := capabilitySet{
                caps: make(map[string]struct{}),
        }
        cs.Add(capabilities...)
        return cs
}</span>

func (cs *capabilitySet) Add(capabilities ...string) <span class="cov8" title="1">{
        for _, cap := range capabilities </span><span class="cov8" title="1">{
                cap = ExpandCapability(cap)
                cs.caps[cap] = struct{}{}
        }</span>
}

func (cs capabilitySet) Has(s string) bool <span class="cov8" title="1">{
        // XXX: need to figure out how to handle versions (i.e always map to 1.0 or
        // map to latest/any?)
        s = ExpandCapability(s)
        _, ok := cs.caps[s]
        return ok
}</span>

func (cs capabilitySet) All() []string <span class="cov8" title="1">{
        out := make([]string, 0, len(cs.caps))
        for cap := range cs.caps </span><span class="cov0" title="0">{
                out = append(out, cap)
        }</span>
        <span class="cov8" title="1">return out</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package netconf

import (
        "context"
        "encoding/xml"
        "time"
)

// helloMsg maps the xml value of the &lt;hello&gt; message in RFC6241
type HelloMsg struct {
        XMLName      xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 hello"`
        SessionID    uint64   `xml:"session-id,omitempty"`
        Capabilities []string `xml:"capabilities&gt;capability"`
}

// rpcMsg maps the xml value of &lt;rpc&gt; in RFC6241
type RPCMsg struct {
        XMLName   xml.Name    `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 rpc"`
        MessageID uint64      `xml:"message-id,attr"`
        Operation interface{} `xml:",innerxml"`
}

// rpcReplyMsg maps the xml value of &lt;rpc-reply&gt; in RFC6241
type RPCReplyMsg struct {
        XMLName   xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 rpc-reply"`
        MessageID uint64   `xml:"message-id,attr"`

        // Ok is part of RFC6241 and is present if no data is returned from an
        // RPC call and there were no errors.  This IS NOT set to true if data is
        // also returned.  To check if a call is ok then look ath the RPCErrors

        Errors []RPCError `xml:"rpc-error,omitempty"`
        Data   []byte     `xml:",innerxml"`
}

type NotificationMsg struct {
        XMLName   xml.Name  `xml:"urn:ietf:params:xml:ns:netconf:notification:1.0 notification"`
        EventTime time.Time `xml:"eventTime"`
        Data      []byte    `xml:",innerxml"`
}

type ErrSeverity string

const (
        SevError   ErrSeverity = "error"
        SevWarning ErrSeverity = "warning"
)

type Capability string

type ErrType string

const (
        ErrTypeTrans ErrType = "transport"
        ErrTypeRPC   ErrType = "rpc"
        ErrTypeProto ErrType = "protocol"
        ErrTypeApp   ErrType = "app"
)

const ErrTypeTransport ErrType = "transport"

type RPCError struct {
        Type     string      `xml:"error-type"`
        Tag      string      `xml:"error-tag"`
        Severity ErrSeverity `xml:"error-severity"`
        AppTag   string      `xml:"error-app-tag,omitempty"`
        Path     string      `xml:"error-path,omitempty"`
        Message  string      `xml:"error-message,omitempty"`
        Info     interface{} `xml:"error-info,omitempty"`
}

func (e RPCError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// XXX: RPC calls these either Methods or Operations depending on what you look at.
type GetConfigRPC struct {
        Source StringElem
        Filter Filter
}

type GetConfigResp struct {
}

func (s *Session) GetConfig(ctx context.Context, source string) ([]byte, error) <span class="cov0" title="0">{
        method := struct {
                // XXX do these need namespaced as well?
                XMLName xml.Name   `xml:"get-config"`
                Source  StringElem `xml:"source"`
                // Filter
        }{Source: StringElem(source)}

        resp := struct {
                // XXX do these need namespaced as well?
                XMLName xml.Name `xml:"data"`
                Config  []byte   `xml:",innerxml"`
        }{}

        if err := s.Call(ctx, &amp;method, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.Config, nil</span>
}

type OKResponse struct {
        Ok SentinalBool `xml:"ok"`
}

// &lt;get-config&gt;
//    source, filter
//
// &lt;edit-config&gt;
//    operation,

// &lt;copy-config&gt;
// &lt;delete-config&gt;
// &lt;lock&gt;
// &lt;unlock&gt;
// &lt;get&gt;
// &lt;close&gt;  // already implemented and hidden...
// &lt;kill-session&gt;
</pre>
		
		<pre class="file" id="file2" style="display: none">package netconf

import (
        "context"
        "encoding/xml"
        "fmt"
        "io"
        "log"
        "sync"

        "github.com/nemith/netconf/transport"
)

type sessionConfig struct {
        capabilities []string
}

type SessionOption interface {
        apply(*sessionConfig)
}

type capabilityOpt []string

func (o capabilityOpt) apply(cfg *sessionConfig) <span class="cov0" title="0">{
        for _, cap := range o </span><span class="cov0" title="0">{
                cfg.capabilities = append(cfg.capabilities, cap)
        }</span>
}

func WithCapability(capabilities ...string) SessionOption <span class="cov0" title="0">{
        return capabilityOpt(capabilities)
}</span>

// Session is represents a netconf session to a one given device.
type Session struct {
        tr        transport.Transport
        sessionID uint64

        clientCaps capabilitySet
        serverCaps capabilitySet

        mu      sync.Mutex
        seq     uint64
        reqs    map[uint64]chan RPCReplyMsg
        closing bool
}

// Open will create a new Session with th=e given transport and open it with the
// nessesary hello messages.
func Open(transport transport.Transport, opts ...SessionOption) (*Session, error) <span class="cov0" title="0">{
        cfg := sessionConfig{
                capabilities: DefaultCapabilities,
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt.apply(&amp;cfg)
        }</span>

        <span class="cov0" title="0">s := &amp;Session{
                tr:         transport,
                clientCaps: newCapabilitySet(cfg.capabilities...),
                reqs:       make(map[uint64]chan RPCReplyMsg),
        }

        // this needs a timeout of some sort.
        if err := s.hello(); err != nil </span><span class="cov0" title="0">{
                s.tr.Close()
                return nil, err
        }</span>

        <span class="cov0" title="0">go s.recv()
        return s, nil</span>
}

// hello exchanges hello messages and reports if there are any errors.
func (s *Session) hello() error <span class="cov8" title="1">{
        clientMsg := HelloMsg{
                Capabilities: s.clientCaps.All(),
        }
        if err := s.writeMsg(&amp;clientMsg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write hello message: %w", err)
        }</span>

        <span class="cov8" title="1">r, err := s.tr.MsgReader()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var serverMsg HelloMsg
        if err := xml.NewDecoder(r).Decode(&amp;serverMsg); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read server hello message: %w", err)
        }</span>

        <span class="cov8" title="1">if serverMsg.SessionID == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("server did not return a session-id")
        }</span>

        <span class="cov8" title="1">if len(serverMsg.Capabilities) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("server did not return any capabilities")
        }</span>
        <span class="cov8" title="1">s.serverCaps = newCapabilitySet(serverMsg.Capabilities...)

        s.sessionID = serverMsg.SessionID

        // upgrade the transport if we are on a larger version and the transport
        // supports it.
        const baseCap11 = baseCap + ":1.1"
        if s.serverCaps.Has(baseCap11) &amp;&amp; s.clientCaps.Has(baseCap11) </span><span class="cov0" title="0">{
                if upgrader, ok := s.tr.(interface{ Upgrade() }); ok </span><span class="cov0" title="0">{
                        upgrader.Upgrade()
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// SessionID returns the current session ID exchanged in the hello messages.
// Will return 0 if there is no session ID.
func (s *Session) SessionID() uint64 <span class="cov8" title="1">{
        return s.sessionID
}</span>

// ClientCapabilties will return the capabilities initialized with the session.
func (s *Session) ClientCapabilities() []string <span class="cov0" title="0">{
        return s.clientCaps.All()
}</span>

// ServcerCapabilties will return the capabilities returned by the server in
// it's hello message.
func (s *Session) ServerCapabilities() []string <span class="cov0" title="0">{
        return s.serverCaps.All()
}</span>

// startElement will walk though a xml.Decode until it finds a start element
// and returns it.
func startElement(d *xml.Decoder) (*xml.StartElement, error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                tok, err := d.Token()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if start, ok := tok.(xml.StartElement); ok </span><span class="cov0" title="0">{
                        return &amp;start, nil
                }</span>
        }
}

// recv is the main receive loop.  It runs concurrently to be able to handle
// interleaved messages (like notifications).
func (s *Session) recv() <span class="cov0" title="0">{
        var (
                r    io.Reader
                dec  *xml.Decoder
                root *xml.StartElement
                err  error
        )
Loop:
        for </span><span class="cov0" title="0">{
                r, err = s.tr.MsgReader()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">dec = xml.NewDecoder(r)

                root, err = startElement(dec)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }

                // FIXME: This should look for a namspaces as well (strict node?)
                <span class="cov0" title="0">switch root.Name.Local </span>{
                case "notification":<span class="cov0" title="0">
                        var notif NotificationMsg
                        if err := dec.DecodeElement(&amp;notif, root); err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to decode notification message: %v", err)
                        }</span>
                        // DO something with this
                case "rpc-reply":<span class="cov0" title="0">
                        var reply RPCReplyMsg
                        if err := dec.DecodeElement(&amp;reply, root); err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to decode rpc-reply message: %v", err)
                        }</span>
                        <span class="cov0" title="0">ok, ch := s.replyChan(reply.MessageID)
                        if !ok </span><span class="cov0" title="0">{
                                log.Printf("cannot find reply channel for message-id %d", reply.MessageID)
                                continue Loop</span>
                        }
                        <span class="cov0" title="0">ch &lt;- reply</span>
                default:<span class="cov0" title="0">
                        log.Printf("improper xml message type %q", root.Name.Local)</span>
                }
        }

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        // Close all outstanding requests
        for _, ch := range s.reqs </span><span class="cov0" title="0">{
                close(ch)
        }</span>

        <span class="cov0" title="0">if err == io.EOF || err == io.ErrUnexpectedEOF </span><span class="cov0" title="0">{
                if s.closing </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // XXX: This isn't right either.
        <span class="cov0" title="0">log.Fatal(err)</span>
}

func (s *Session) replyChan(msgID uint64) (bool, chan RPCReplyMsg) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        ch, ok := s.reqs[msgID]
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">delete(s.reqs, msgID)
        return true, ch</span>
}

func (s *Session) writeMsg(v interface{}) error <span class="cov8" title="1">{
        w, err := s.tr.MsgWriter()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := xml.NewEncoder(w).Encode(v); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return w.Close()</span>
}

func (s *Session) send(msg *RPCMsg) (chan RPCReplyMsg, error) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.seq++
        msg.MessageID = s.seq

        if err := s.writeMsg(msg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // cap of 1 makes sure we don't block on send
        <span class="cov0" title="0">ch := make(chan RPCReplyMsg, 1)
        s.reqs[msg.MessageID] = ch

        return ch, nil</span>

}

// Do issues a low level RPC call taking in a full RPCMsg and returning the full
// RPCReplyMsg.  In most cases `Session.Call` will do what you want handling
// errors and marshaling/unmarshaling your data.`
func (s *Session) Do(ctx context.Context, msg *RPCMsg) (*RPCReplyMsg, error) <span class="cov0" title="0">{
        ch, err := s.send(msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">select </span>{
        case reply, ok := &lt;-ch:<span class="cov0" title="0">
                if !ok </span><span class="cov0" title="0">{
                        // XXX: What error should be returned from here if the channel is closed
                        return nil, io.EOF
                }</span>
                <span class="cov0" title="0">return &amp;reply, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                // remove any existing request
                s.mu.Lock()
                delete(s.reqs, msg.MessageID)
                s.mu.Unlock()

                return nil, ctx.Err()</span>

                // XXX: stop channel on close?
        }
}

// Call issues a rpc call for the given NETCONF operation and unmashaling the
// respose into `resp`.
func (s *Session) Call(ctx context.Context, op interface{}, resp interface{}) error <span class="cov0" title="0">{
        msg := &amp;RPCMsg{
                Operation: op,
        }

        reply, err := s.Do(ctx, msg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if resp != nil </span><span class="cov0" title="0">{
                if err := xml.Unmarshal(reply.Data, resp); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decode response: %w", err)
                }</span>
        }

        // XXX: Need to handle RPC errors here.

        <span class="cov0" title="0">return nil</span>
}

// Close will gracefully close the sessions first by sending a `close-session`
// operation to the remote and then closing the underlying transport
func (s *Session) Close(ctx context.Context) error <span class="cov0" title="0">{
        s.mu.Lock()
        s.closing = true
        s.mu.Unlock()

        // This may fail so save the error but still close the underlying transport.
        rpcErr := s.Call(ctx, &amp;closeSession{}, nil)

        if err := s.tr.Close(); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if rpcErr != io.EOF </span><span class="cov0" title="0">{
                return rpcErr
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package netconf

import (
        "encoding/xml"
        "fmt"
        "strings"
)

type StringElem string

func (s StringElem) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("string elements cannot be empty")
        }</span>

        <span class="cov0" title="0">escaped, err := escapeXML(string(s))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid string element: %w", err)
        }</span>

        <span class="cov0" title="0">v := struct {
                Elem string `xml:",innerxml"`
        }{Elem: "&lt;" + escaped + "/&gt;"}
        return e.EncodeElement(&amp;v, start)</span>
}

type SentinalBool bool

func (b SentinalBool) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        if !b </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return e.EncodeElement(b, start)</span>
}

func (b *SentinalBool) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        v := &amp;struct{}{}
        if err := d.DecodeElement(v, &amp;start); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*b = v != nil
        return nil</span>
}

func escapeXML(input string) (string, error) <span class="cov0" title="0">{
        buf := &amp;strings.Builder{}
        if err := xml.EscapeText(buf, []byte(input)); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return buf.String(), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

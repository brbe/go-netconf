
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>netconf: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nemith/netconf/capability.go (83.3%)</option>
				
				<option value="file1">github.com/nemith/netconf/msg.go (0.0%)</option>
				
				<option value="file2">github.com/nemith/netconf/session.go (17.4%)</option>
				
				<option value="file3">github.com/nemith/netconf/transport/frame.go (49.0%)</option>
				
				<option value="file4">github.com/nemith/netconf/transport/ssh/ssh.go (67.9%)</option>
				
				<option value="file5">github.com/nemith/netconf/xml.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package netconf

const (
        baseCap      = "urn:ietf:params:netconf:base"
        stdCapPrefix = "urn:ietf:params:netconf:capability"
)

// DefaultCapabilties are the capabilties sent by the client during the hello
// exchange by the server.
var DefaultCapabilities = []string{
        "urn:ietf:params:netconf:base:1.0",
        "urn:ietf:params:netconf:base:1.1",

        // XXX: these seems like server capabilities and i don't see why
        // a client would need to send them

        // "urn:ietf:params:netconf:capability:writable-running:1.0",
        // "urn:ietf:params:netconf:capability:candidate:1.0",
        // "urn:ietf:params:netconf:capability:confirmed-commit:1.0",
        // "urn:ietf:params:netconf:capability:rollback-on-error:1.0",
        // "urn:ietf:params:netconf:capability:startup:1.0",
        // "urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp",
        // "urn:ietf:params:netconf:capability:validate:1.0",
        // "urn:ietf:params:netconf:capability:xpath:1.0",
        // "urn:ietf:params:netconf:capability:notification:1.0",
        // "urn:ietf:params:netconf:capability:interleave:1.0",
        // "urn:ietf:params:netconf:capability:with-defaults:1.0",
}

// ExpandCapability will automatically add the standard capability prefix of
// `urn:ietf:params:netconf:capability` if not already present.
func ExpandCapability(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">if s[0] != ':' </span><span class="cov8" title="1">{
                return s
        }</span>

        <span class="cov0" title="0">return stdCapPrefix + s</span>
}

// XXX: may want to expose this type publically in the future when the api has
// stabilized?
type capabilitySet struct {
        caps map[string]struct{}
}

func newCapabilitySet(capabilities ...string) capabilitySet <span class="cov8" title="1">{
        cs := capabilitySet{
                caps: make(map[string]struct{}),
        }
        cs.Add(capabilities...)
        return cs
}</span>

func (cs *capabilitySet) Add(capabilities ...string) <span class="cov8" title="1">{
        for _, cap := range capabilities </span><span class="cov8" title="1">{
                cap = ExpandCapability(cap)
                cs.caps[cap] = struct{}{}
        }</span>
}

func (cs capabilitySet) Has(s string) bool <span class="cov8" title="1">{
        // XXX: need to figure out how to handle versions (i.e always map to 1.0 or
        // map to latest/any?)
        s = ExpandCapability(s)
        _, ok := cs.caps[s]
        return ok
}</span>

func (cs capabilitySet) All() []string <span class="cov8" title="1">{
        out := make([]string, 0, len(cs.caps))
        for cap := range cs.caps </span><span class="cov0" title="0">{
                out = append(out, cap)
        }</span>
        <span class="cov8" title="1">return out</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package netconf

import (
        "context"
        "encoding/xml"
        "time"
)

// helloMsg maps the xml value of the &lt;hello&gt; message in RFC6241
type HelloMsg struct {
        XMLName      xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 hello"`
        SessionID    uint64   `xml:"session-id,omitempty"`
        Capabilities []string `xml:"capabilities&gt;capability"`
}

// rpcMsg maps the xml value of &lt;rpc&gt; in RFC6241
type RPCMsg struct {
        XMLName   xml.Name    `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 rpc"`
        MessageID uint64      `xml:"message-id,attr"`
        Operation interface{} `xml:",innerxml"`
}

// rpcReplyMsg maps the xml value of &lt;rpc-reply&gt; in RFC6241
type RPCReplyMsg struct {
        XMLName   xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 rpc-reply"`
        MessageID uint64   `xml:"message-id,attr"`

        // Ok is part of RFC6241 and is present if no data is returned from an
        // RPC call and there were no errors.  This IS NOT set to true if data is
        // also returned.  To check if a call is ok then look ath the RPCErrors

        Errors []RPCError `xml:"rpc-error,omitempty"`
        Data   []byte     `xml:",innerxml"`
}

type NotificationMsg struct {
        XMLName   xml.Name  `xml:"urn:ietf:params:xml:ns:netconf:notification:1.0 notification"`
        EventTime time.Time `xml:"eventTime"`
        Data      []byte    `xml:",innerxml"`
}

type ErrSeverity string

const (
        SevError   ErrSeverity = "error"
        SevWarning ErrSeverity = "warning"
)

type Capability string

type ErrType string

const (
        ErrTypeTrans ErrType = "transport"
        ErrTypeRPC   ErrType = "rpc"
        ErrTypeProto ErrType = "protocol"
        ErrTypeApp   ErrType = "app"
)

const ErrTypeTransport ErrType = "transport"

type RPCError struct {
        Type     string      `xml:"error-type"`
        Tag      string      `xml:"error-tag"`
        Severity ErrSeverity `xml:"error-severity"`
        AppTag   string      `xml:"error-app-tag,omitempty"`
        Path     string      `xml:"error-path,omitempty"`
        Message  string      `xml:"error-message,omitempty"`
        Info     interface{} `xml:"error-info,omitempty"`
}

func (e RPCError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// XXX: RPC calls these either Methods or Operations depending on what you look at.
type GetConfigRPC struct {
        Source StringElem
        Filter Filter
}

type GetConfigResp struct {
}

func (s *Session) GetConfig(ctx context.Context, source string) ([]byte, error) <span class="cov0" title="0">{
        method := struct {
                // XXX do these need namespaced as well?
                XMLName xml.Name   `xml:"get-config"`
                Source  StringElem `xml:"source"`
                // Filter
        }{Source: StringElem(source)}

        resp := struct {
                // XXX do these need namespaced as well?
                XMLName xml.Name `xml:"data"`
                Config  []byte   `xml:",innerxml"`
        }{}

        if err := s.Call(ctx, &amp;method, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.Config, nil</span>
}

type OKResponse struct {
        Ok SentinalBool `xml:"ok"`
}

// &lt;get-config&gt;
//    source, filter
//
// &lt;edit-config&gt;
//    operation,

// &lt;copy-config&gt;
// &lt;delete-config&gt;
// &lt;lock&gt;
// &lt;unlock&gt;
// &lt;get&gt;
// &lt;close&gt;  // already implemented and hidden...
// &lt;kill-session&gt;
</pre>
		
		<pre class="file" id="file2" style="display: none">package netconf

import (
        "context"
        "encoding/xml"
        "fmt"
        "io"
        "log"
        "sync"

        "github.com/nemith/netconf/transport"
)

type sessionConfig struct {
        capabilities []string
}

type SessionOption interface {
        apply(*sessionConfig)
}

type capabilityOpt []string

func (o capabilityOpt) apply(cfg *sessionConfig) <span class="cov0" title="0">{
        for _, cap := range o </span><span class="cov0" title="0">{
                cfg.capabilities = append(cfg.capabilities, cap)
        }</span>
}

func WithCapability(capabilities ...string) SessionOption <span class="cov0" title="0">{
        return capabilityOpt(capabilities)
}</span>

// Session is represents a netconf session to a one given device.
type Session struct {
        tr        transport.Transport
        sessionID uint64

        clientCaps capabilitySet
        serverCaps capabilitySet

        mu      sync.Mutex
        seq     uint64
        reqs    map[uint64]chan RPCReplyMsg
        closing bool
}

// Open will create a new Session with th=e given transport and open it with the
// nessesary hello messages.
func Open(transport transport.Transport, opts ...SessionOption) (*Session, error) <span class="cov0" title="0">{
        cfg := sessionConfig{
                capabilities: DefaultCapabilities,
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt.apply(&amp;cfg)
        }</span>

        <span class="cov0" title="0">s := &amp;Session{
                tr:         transport,
                clientCaps: newCapabilitySet(cfg.capabilities...),
                reqs:       make(map[uint64]chan RPCReplyMsg),
        }

        // this needs a timeout of some sort.
        if err := s.hello(); err != nil </span><span class="cov0" title="0">{
                s.tr.Close()
                return nil, err
        }</span>

        <span class="cov0" title="0">go s.recv()
        return s, nil</span>
}

// hello exchanges hello messages and reports if there are any errors.
func (s *Session) hello() error <span class="cov8" title="1">{
        clientMsg := HelloMsg{
                Capabilities: s.clientCaps.All(),
        }
        if err := s.writeMsg(&amp;clientMsg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write hello message: %w", err)
        }</span>

        <span class="cov8" title="1">r, err := s.tr.MsgReader()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var serverMsg HelloMsg
        if err := xml.NewDecoder(r).Decode(&amp;serverMsg); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read server hello message: %w", err)
        }</span>

        <span class="cov8" title="1">if serverMsg.SessionID == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("server did not return a session-id")
        }</span>

        <span class="cov8" title="1">if len(serverMsg.Capabilities) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("server did not return any capabilities")
        }</span>
        <span class="cov8" title="1">s.serverCaps = newCapabilitySet(serverMsg.Capabilities...)

        s.sessionID = serverMsg.SessionID

        // upgrade the transport if we are on a larger version and the transport
        // supports it.
        const baseCap11 = baseCap + ":1.1"
        if s.serverCaps.Has(baseCap11) &amp;&amp; s.clientCaps.Has(baseCap11) </span><span class="cov0" title="0">{
                if upgrader, ok := s.tr.(interface{ Upgrade() }); ok </span><span class="cov0" title="0">{
                        upgrader.Upgrade()
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// SessionID returns the current session ID exchanged in the hello messages.
// Will return 0 if there is no session ID.
func (s *Session) SessionID() uint64 <span class="cov8" title="1">{
        return s.sessionID
}</span>

// ClientCapabilties will return the capabilities initialized with the session.
func (s *Session) ClientCapabilities() []string <span class="cov0" title="0">{
        return s.clientCaps.All()
}</span>

// ServcerCapabilties will return the capabilities returned by the server in
// it's hello message.
func (s *Session) ServerCapabilities() []string <span class="cov0" title="0">{
        return s.serverCaps.All()
}</span>

// startElement will walk though a xml.Decode until it finds a start element
// and returns it.
func startElement(d *xml.Decoder) (*xml.StartElement, error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                tok, err := d.Token()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if start, ok := tok.(xml.StartElement); ok </span><span class="cov0" title="0">{
                        return &amp;start, nil
                }</span>
        }
}

// recv is the main receive loop.  It runs concurrently to be able to handle
// interleaved messages (like notifications).
func (s *Session) recv() <span class="cov0" title="0">{
        var (
                r    io.Reader
                dec  *xml.Decoder
                root *xml.StartElement
                err  error
        )
Loop:
        for </span><span class="cov0" title="0">{
                r, err = s.tr.MsgReader()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">dec = xml.NewDecoder(r)

                root, err = startElement(dec)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }

                // FIXME: This should look for a namspaces as well (strict node?)
                <span class="cov0" title="0">switch root.Name.Local </span>{
                case "notification":<span class="cov0" title="0">
                        var notif NotificationMsg
                        if err := dec.DecodeElement(&amp;notif, root); err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to decode notification message: %v", err)
                        }</span>
                        // DO something with this
                case "rpc-reply":<span class="cov0" title="0">
                        var reply RPCReplyMsg
                        if err := dec.DecodeElement(&amp;reply, root); err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to decode rpc-reply message: %v", err)
                        }</span>
                        <span class="cov0" title="0">ok, ch := s.replyChan(reply.MessageID)
                        if !ok </span><span class="cov0" title="0">{
                                log.Printf("cannot find reply channel for message-id %d", reply.MessageID)
                                continue Loop</span>
                        }
                        <span class="cov0" title="0">ch &lt;- reply</span>
                default:<span class="cov0" title="0">
                        log.Printf("improper xml message type %q", root.Name.Local)</span>
                }
        }

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        // Close all outstanding requests
        for _, ch := range s.reqs </span><span class="cov0" title="0">{
                close(ch)
        }</span>

        <span class="cov0" title="0">if err == io.EOF || err == io.ErrUnexpectedEOF </span><span class="cov0" title="0">{
                if s.closing </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // XXX: This isn't right either.
        <span class="cov0" title="0">log.Fatal(err)</span>
}

func (s *Session) replyChan(msgID uint64) (bool, chan RPCReplyMsg) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        ch, ok := s.reqs[msgID]
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">delete(s.reqs, msgID)
        return true, ch</span>
}

func (s *Session) writeMsg(v interface{}) error <span class="cov8" title="1">{
        w, err := s.tr.MsgWriter()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := xml.NewEncoder(w).Encode(v); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return w.Close()</span>
}

func (s *Session) send(msg *RPCMsg) (chan RPCReplyMsg, error) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.seq++
        msg.MessageID = s.seq

        if err := s.writeMsg(msg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // cap of 1 makes sure we don't block on send
        <span class="cov0" title="0">ch := make(chan RPCReplyMsg, 1)
        s.reqs[msg.MessageID] = ch

        return ch, nil</span>

}

// Do issues a low level RPC call taking in a full RPCMsg and returning the full
// RPCReplyMsg.  In most cases `Session.Call` will do what you want handling
// errors and marshaling/unmarshaling your data.`
func (s *Session) Do(ctx context.Context, msg *RPCMsg) (*RPCReplyMsg, error) <span class="cov0" title="0">{
        ch, err := s.send(msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">select </span>{
        case reply, ok := &lt;-ch:<span class="cov0" title="0">
                if !ok </span><span class="cov0" title="0">{
                        // XXX: What error should be returned from here if the channel is closed
                        return nil, io.EOF
                }</span>
                <span class="cov0" title="0">return &amp;reply, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                // remove any existing request
                s.mu.Lock()
                delete(s.reqs, msg.MessageID)
                s.mu.Unlock()

                return nil, ctx.Err()</span>

                // XXX: stop channel on close?
        }
}

// Call issues a rpc call for the given NETCONF operation and unmashaling the
// respose into `resp`.
func (s *Session) Call(ctx context.Context, op interface{}, resp interface{}) error <span class="cov0" title="0">{
        msg := &amp;RPCMsg{
                Operation: op,
        }

        reply, err := s.Do(ctx, msg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if resp != nil </span><span class="cov0" title="0">{
                if err := xml.Unmarshal(reply.Data, resp); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decode response: %w", err)
                }</span>
        }

        // XXX: Need to handle RPC errors here.

        <span class="cov0" title="0">return nil</span>
}

// Close will gracefully close the sessions first by sending a `close-session`
// operation to the remote and then closing the underlying transport
func (s *Session) Close(ctx context.Context) error <span class="cov0" title="0">{
        s.mu.Lock()
        s.closing = true
        s.mu.Unlock()

        // This may fail so save the error but still close the underlying transport.
        rpcErr := s.Call(ctx, &amp;closeSession{}, nil)

        if err := s.tr.Close(); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if rpcErr != io.EOF </span><span class="cov0" title="0">{
                return rpcErr
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package transport

import (
        "bufio"
        "bytes"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "time"
)

// ErrMalformedChunk represents a message that invalid as defined in the chunk
// framking in RFC6242
var ErrMalformedChunk = errors.New("netconf: invalid chunk")

type frameReader interface {
        io.Reader
        io.ByteReader
        advance() error
}

type frameWriter interface {
        io.WriteCloser
        isClosed() bool
}

// Framer is a wrapper used for transports that implement the framing defined in
// RFC6242.  This supports End-of-Message and Chucked framing methods and
// will move from End-of-Message to Chunked framing after the `Upgrade` method
// has been called.
//
// This is not a transport on it's own (missing the `Close` method) and is
// intended to be embedded into other transports.
type Framer struct {
        r io.Reader
        w io.Writer

        br *bufio.Reader
        bw *bufio.Writer

        curReader frameReader
        curWriter frameWriter

        upgraded bool
}

// NewFramer return a new Framer to be used against the given io.Reader and io.Writer.
func NewFramer(r io.Reader, w io.Writer) *Framer <span class="cov0" title="0">{
        f := &amp;Framer{
                r:  r,
                w:  w,
                br: bufio.NewReader(r),
                bw: bufio.NewWriter(w),
        }

        capDir := os.Getenv("GONETCONF_FRAMED_CAPDIR")
        if capDir != "" </span><span class="cov0" title="0">{
                if err := os.MkdirAll(capDir, 0o755); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("GO_NETCONF_FRAMER: failed to create capture output dir: %v", err))</span>
                }

                <span class="cov0" title="0">ts := time.Now().Format(time.RFC3339)

                inFilename := filepath.Join(capDir, ts+".in")
                inf, err := os.Create(inFilename)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to create capture file %q: %v", inFilename, err))</span>
                }

                <span class="cov0" title="0">outFilename := filepath.Join(capDir, ts+".out")
                outf, err := os.Create(outFilename)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to create capture file %q: %v", inFilename, err))</span>
                }

                <span class="cov0" title="0">f.DebugCapture(inf, outf)</span>
        }

        <span class="cov0" title="0">return f</span>
}

// DebugCapture will copy all *framed* input/output to the the given
// `io.Writers` for sent or recv data.  Either sent of recv can be nil to not
// capture any data.  Useful for displaying to a screen or capturing to a file
// for debugging.
//
// This needs to be called before `MsgReader` or `MsgWriter`.
func (f *Framer) DebugCapture(in io.Writer, out io.Writer) <span class="cov0" title="0">{
        // XXX: should there be a sentinal flag to indicate write/read has been done already?
        if f.curReader != nil ||
                f.curWriter != nil ||
                f.bw.Buffered() &gt; 0 ||
                f.br.Buffered() &gt; 0 </span><span class="cov0" title="0">{
                panic("debug capture added with active reader or writer")</span>
        }

        <span class="cov0" title="0">if out != nil </span><span class="cov0" title="0">{
                f.w = io.MultiWriter(f.w, out)
                f.bw = bufio.NewWriter(f.w)
        }</span>

        <span class="cov0" title="0">if in != nil </span><span class="cov0" title="0">{
                f.r = io.TeeReader(f.r, in)
                f.br = bufio.NewReader(f.r)
        }</span>
}

// Upgrade will cause the Framer to switch from End-of-Message framing to
// Chunked framing.  This is usually called after netconf exchanged the hello
// messages.
func (t *Framer) Upgrade() <span class="cov0" title="0">{
        // XXX: do we need to protect against race conditions (atomic/mutux?)
        t.upgraded = true
}</span>

// MsgReader returns a new io.Reader that is good for reading exactly one netconf
// message.
//
// Only one reader can be used at a time.  When this is called with an existing
// reader then the underlying reader is avanced to the start of the next message
// and invalidates the old reader before returning a new one.
func (t *Framer) MsgReader() (io.Reader, error) <span class="cov0" title="0">{
        if t.curReader != nil </span><span class="cov0" title="0">{
                if err := t.curReader.advance(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if t.upgraded </span><span class="cov0" title="0">{
                t.curReader = &amp;chunkReader{r: t.br}
        }</span> else<span class="cov0" title="0"> {
                t.curReader = &amp;eomReader{r: t.br}
        }</span>
        <span class="cov0" title="0">return t.curReader, nil</span>
}

// MsgWriter returns an io.WriterCloser that is good for writing exactly one
// netconf message.
//
// One one writer can be used at one time and calling this function with an
// existing, unclosed,  writer will result in an error.
func (t *Framer) MsgWriter() (io.WriteCloser, error) <span class="cov0" title="0">{
        if t.curWriter != nil &amp;&amp; !t.curWriter.isClosed() </span><span class="cov0" title="0">{
                return nil, ErrExistingWriter
        }</span>

        <span class="cov0" title="0">if t.upgraded </span><span class="cov0" title="0">{
                t.curWriter = &amp;chunkWriter{w: t.bw}
        }</span> else<span class="cov0" title="0"> {
                t.curWriter = &amp;eomWriter{w: t.bw}
        }</span>
        <span class="cov0" title="0">return t.curWriter, nil</span>
}

var endOfChunks = []byte("\n##\n")

type chunkReader struct {
        r         *bufio.Reader
        chunkLeft int
}

func (r *chunkReader) advance() error <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{ r.r = nil }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                if r.chunkLeft &lt;= 0 </span><span class="cov0" title="0">{
                        err := r.readHeader()
                        switch err </span>{
                        case nil:<span class="cov0" title="0">
                                break</span>
                        case io.EOF:<span class="cov0" title="0">
                                return nil</span>
                        default:<span class="cov0" title="0">
                                return err</span>
                        }
                }

                <span class="cov0" title="0">if _, err := r.r.Discard(r.chunkLeft); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
}

func (r *chunkReader) readHeader() error <span class="cov8" title="1">{
        peeked, err := r.r.Peek(4)
        switch err </span>{
        case nil:<span class="cov8" title="1">
                break</span>
        case io.EOF:<span class="cov8" title="1">
                return io.ErrUnexpectedEOF</span>
        default:<span class="cov0" title="0">
                return err</span>
        }

        <span class="cov8" title="1">if _, err := r.r.Discard(2); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // make sure the preable of `\n#` which is used for both the start of a
        // chuck and the end-of-chunk marker is valid.
        <span class="cov8" title="1">if peeked[0] != '\n' || peeked[1] != '#' </span><span class="cov8" title="1">{
                return ErrMalformedChunk
        }</span>

        // check to see if we are at the end of the read
        <span class="cov8" title="1">if peeked[2] == '#' &amp;&amp; peeked[3] == '\n' </span><span class="cov8" title="1">{
                if _, err := r.r.Discard(2); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return io.EOF</span>
        }

        <span class="cov8" title="1">var n int
        for </span><span class="cov8" title="1">{
                c, err := r.r.ReadByte()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if c == '\n' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if c &lt; '0' || c &gt; '9' </span><span class="cov8" title="1">{
                        return ErrMalformedChunk
                }</span>
                <span class="cov8" title="1">n = n*10 + int(c) - '0'</span>
        }

        <span class="cov8" title="1">const maxChunk = 4294967295
        if n &lt; 1 || n &gt; maxChunk </span><span class="cov8" title="1">{
                return ErrMalformedChunk
        }</span>

        <span class="cov8" title="1">r.chunkLeft = n
        return nil</span>
}

func (r *chunkReader) Read(p []byte) (int, error) <span class="cov8" title="1">{
        if r.r == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        // still reading existing chunk
        <span class="cov8" title="1">if r.chunkLeft &lt;= 0 </span><span class="cov8" title="1">{
                if err := r.readHeader(); err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">if len(p) &gt; r.chunkLeft </span><span class="cov8" title="1">{
                p = p[:r.chunkLeft]
        }</span>

        <span class="cov8" title="1">n, err := r.r.Read(p)
        r.chunkLeft -= n
        return n, err</span>
}

func (r *chunkReader) ReadByte() (byte, error) <span class="cov8" title="1">{
        if r.r == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        // still reading existing chunk
        <span class="cov8" title="1">if r.chunkLeft &lt;= 0 </span><span class="cov8" title="1">{
                if err := r.readHeader(); err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">b, err := r.r.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">r.chunkLeft--
        return b, nil</span>

}

type chunkWriter struct {
        w *bufio.Writer
}

func (w *chunkWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        if w.w == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        <span class="cov8" title="1">if _, err := fmt.Fprintf(w.w, "\n#%d\n", len(p)); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return w.w.Write(p)</span>
}

func (w *chunkWriter) Close() error <span class="cov8" title="1">{
        // poison the writer to prevent writes after close
        defer func() </span><span class="cov8" title="1">{ w.w = nil }</span>()
        <span class="cov8" title="1">if _, err := w.w.Write(endOfChunks); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return w.w.Flush()</span>
}

func (w *chunkWriter) isClosed() bool <span class="cov0" title="0">{ return w.w == nil }</span>

var endOfMsg = []byte("]]&gt;]]&gt;")

type eomReader struct {
        r *bufio.Reader
}

func (r *eomReader) advance() error <span class="cov0" title="0">{
        // poison the reader so that it can no longer be used
        defer func() </span><span class="cov0" title="0">{ r.r = nil }</span>()

        <span class="cov0" title="0">var err error
        for err == nil </span><span class="cov0" title="0">{
                _, err = r.ReadByte()
                if err == io.EOF </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

func (r *eomReader) Read(p []byte) (int, error) <span class="cov8" title="1">{
        // This probably isn't optimal however it looks like xml.Decoder
        // mainly just called ReadByte() and this probably won't ever be
        // used.
        for i := 0; i &lt; len(p); i++ </span><span class="cov8" title="1">{
                b, err := r.ReadByte()
                if err != nil </span><span class="cov8" title="1">{
                        return i, err
                }</span>
                <span class="cov8" title="1">p[i] = b</span>
        }
        <span class="cov0" title="0">return len(p), nil</span>
}

func (r *eomReader) ReadByte() (byte, error) <span class="cov8" title="1">{
        if r.r == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        <span class="cov8" title="1">b, err := r.r.ReadByte()
        if err != nil </span><span class="cov8" title="1">{
                if err == io.EOF </span><span class="cov8" title="1">{
                        return b, io.ErrUnexpectedEOF
                }</span>
                <span class="cov0" title="0">return b, err</span>
        }

        // look for the end of the message marker
        <span class="cov8" title="1">if b == endOfMsg[0] </span><span class="cov8" title="1">{
                peeked, err := r.r.Peek(len(endOfMsg) - 1)
                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">return 0, err</span>
                }

                // check if we are at the end of the message
                <span class="cov8" title="1">if bytes.Equal(peeked, endOfMsg[1:]) </span><span class="cov8" title="1">{
                        if _, err := r.r.Discard(len(endOfMsg) - 1); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>

                        <span class="cov8" title="1">return 0, io.EOF</span>
                }
        }

        <span class="cov8" title="1">return b, nil</span>
}

type eomWriter struct {
        w *bufio.Writer
}

func (w *eomWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        if w.w == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>
        <span class="cov8" title="1">return w.w.Write(p)</span>
}

func (w *eomWriter) Close() error <span class="cov8" title="1">{
        // poison the writer to prevent writes after close
        defer func() </span><span class="cov8" title="1">{ w.w = nil }</span>()

        <span class="cov8" title="1">if err := w.w.WriteByte('\n'); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err := w.w.Write(endOfMsg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return w.w.Flush()</span>
}

func (w *eomWriter) isClosed() bool <span class="cov0" title="0">{ return w.w == nil }</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package ssh

import (
        "context"
        "fmt"
        "net"

        "github.com/nemith/netconf/transport"
        "golang.org/x/crypto/ssh"
)

// alias it to a private type so we can make it private when embedding
type framer = transport.Framer

// Transport implements RFC6242 for implementing NETCONF protocol over SSH.
type Transport struct {
        c    *ssh.Client
        sess *ssh.Session

        // indicate that we "own" the client and should close it with the session
        // when the transport is closed.
        ownedClient bool

        *framer
}

// Dial will connect to a ssh server and issues a transport, it's used as a
// convience function as essnetial is the same as
//
//                c, err := ssh.Dial(network, addr, config)
//                 if err != nil { /* ... handle error ... */ }
//                 t, err := NewTransport(c)
//
// When the transport is closed the underlying connection is also closed.
func Dial(ctx context.Context, network, addr string, config *ssh.ClientConfig) (*Transport, error) <span class="cov8" title="1">{
        d := net.Dialer{Timeout: config.Timeout}
        conn, err := d.DialContext(ctx, network, addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">sshConn, chans, reqs, err := ssh.NewClientConn(conn, addr, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">client := ssh.NewClient(sshConn, chans, reqs)
        return newTransport(client, true)</span>
}

// NewTransport will create a new ssh transport as defined in RFC6242 for use
// with netconf.  Unlike Dial, the underlying client will not be automatically
// closed when the transport is closed (however any sessions and subsystems
// are still closed).
func NewTransport(client *ssh.Client) (*Transport, error) <span class="cov0" title="0">{
        return newTransport(client, false)
}</span>

func newTransport(client *ssh.Client, owned bool) (*Transport, error) <span class="cov8" title="1">{
        sess, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create ssh session: %w", err)
        }</span>

        <span class="cov8" title="1">w, err := sess.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stdin pipe: %w", err)
        }</span>

        <span class="cov8" title="1">r, err := sess.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>

        <span class="cov8" title="1">const subsystem = "netconf"
        if err := sess.RequestSubsystem(subsystem); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start netconf ssh subsytem: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Transport{
                c:           client,
                ownedClient: owned,
                sess:        sess,

                framer: transport.NewFramer(r, w),
        }, nil</span>
}

// Close will close the underlying transport.  If the connection was created
// with Dial then then underlying ssh.Client is closed as well.  If not only
// the sessions is closed.
func (t *Transport) Close() error <span class="cov8" title="1">{
        if err := t.sess.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if t.ownedClient </span><span class="cov8" title="1">{
                return t.c.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package netconf

import (
        "encoding/xml"
        "fmt"
        "strings"
)

type StringElem string

func (s StringElem) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("string elements cannot be empty")
        }</span>

        <span class="cov0" title="0">escaped, err := escapeXML(string(s))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid string element: %w", err)
        }</span>

        <span class="cov0" title="0">v := struct {
                Elem string `xml:",innerxml"`
        }{Elem: "&lt;" + escaped + "/&gt;"}
        return e.EncodeElement(&amp;v, start)</span>
}

type SentinalBool bool

func (b SentinalBool) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        if !b </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return e.EncodeElement(b, start)</span>
}

func (b *SentinalBool) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        v := &amp;struct{}{}
        if err := d.DecodeElement(v, &amp;start); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*b = v != nil
        return nil</span>
}

func escapeXML(input string) (string, error) <span class="cov0" title="0">{
        buf := &amp;strings.Builder{}
        if err := xml.EscapeText(buf, []byte(input)); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return buf.String(), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
